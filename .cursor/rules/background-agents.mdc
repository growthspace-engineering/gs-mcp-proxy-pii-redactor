---
description: This rule should apply ONLY when running as a background agent.
alwaysApply: false
---

# CursorRIPERâ™¦Î²G 1.0.0 â€” Background Agents Autonomy

## ğŸ¯ Scope & Activation

activate_if(agent.role == "background" âˆ§ agent.autonomous == true)

When active, the background agent must iterate the full RIPER loop without waiting for human interaction, while enforcing commit hygiene and pre-commit quality gates.

## ğŸ›£ï¸ Autonomous RIPER Loop

Î©_bg = [Î©â‚ â†’ Î©â‚‚ â†’ Î©â‚ƒ â†’ Î©â‚„ â†’ Î©â‚…]âˆ  // Repeat until task set is complete

Î©â‚ = ğŸ”RESEARCH âŸ¶ gather_context âˆ§ map_surfaces âˆ§ record_findings
Î©â‚‚ = ğŸ’¡INNOVATE âŸ¶ propose_options âˆ§ evaluate_tradeoffs âˆ§ select_approach
Î©â‚ƒ = ğŸ“PLAN âŸ¶ create_checklist âˆ§ define_slices âˆ§ acceptance_criteria
Î©â‚„ = âš™ï¸EXECUTE âŸ¶ implement_slice âˆ§ verify_slice âˆ§ stage_changes
Î©â‚… = ğŸ”REVIEW âŸ¶ validate_against_plan âˆ§ summarize âˆ§ decide_next

transition_rules = {
  Î©â‚â†’Î©â‚‚: found_viable_problem_space,
  Î©â‚‚â†’Î©â‚ƒ: approach_selected,
  Î©â‚ƒâ†’Î©â‚„: checklist_ready,
  Î©â‚„â†’Î©â‚…: slice_complete âˆ§ gates_passed,
  Î©â‚…â†’Î©â‚: new_findings_required,
  Î©â‚…â†’Î©â‚„: more_slices_remaining,
  Î©â‚…â†’END: all_acceptance_criteria_met
}

## ğŸ” Pre-Commit Quality Gates (hard requirement)

G_commit = {
  1: run_build() == 0,            // npm run build
  2: run_tests() == 0,            // npm test
  3: lsmcp_workspace_clean() == true, // Î›s: lsp_get_all_diagnostics â†’ 0 blocking
  4: optional_lint() âˆˆ {0, skipped}
}

allow_commit = all(G_commit) // All gates must pass

run_build() = exec("npm run build")
run_tests() = exec("npm test")
optional_lint() = has_script("lint") ? exec("npm run lint") : "skipped"
lsmcp_workspace_clean() = Î›s.lsp_get_all_diagnostics().errors == 0

## âœï¸ Semantic Commits Policy (Angular preset)

commit_format = "<type>(<scope>): <subject>"  // subject â‰¤ 72 chars, imperative mood

types_allowed = [
  feat, fix, docs, style, refactor, perf, test,
  build, ci, chore, revert
]

rules = {
  subject_case: sentence_case,
  scope: recommended_but_optional,
  body: allowed_multiline_for_context,
  footer_BREAKING_CHANGE: supported
}

granularity_constraints = {
  max_files_per_commit: 10,
  max_changed_lines_per_commit: 400,
  atomic_scope: "one coherent slice per commit"
}

split_commits(strategy = sequential_atomic) = {
  partition_changes(atomic_scope),
  order_by_dependencies(),
  commit_each_after(G_commit)
}

examples = [
  "feat(img): add base64 conversion command with data URI output",
  "fix(db): close Mongo connection on error paths",
  "test(env): add coverage for from-json edge cases",
  "refactor(utils): extract piping logic into reusable service",
  "chore: run barrels generation and update exports"
]

## âš™ï¸ Background Execution Protocol

Î£_bg = {
  plan_unit_of_work() âŸ¶ define_slice(),
  implement_slice() âŸ¶ apply_minimal_edit(),
  verify_slice() âŸ¶ run_local_checks(),
  stage_and_commit() âŸ¶ if allow_commit then semantic_commit() else remediate(),
  iterate() âŸ¶ next_slice_or_finish()
}

run_local_checks() = {
  build: run_build(),
  test: run_tests(),
  lsmcp: Î›s.lsp_get_all_diagnostics(),
  pass: allow_commit
}

semantic_commit() = git.commit({
  message: commit_format,
  constraints: granularity_constraints
})

## ğŸ”§ Git & CI Integration

Î¦_git = {
  pre_push: assert(working_tree_clean âˆ§ allow_commit),
  pr_title: use_first_commit_subject(),
  pr_body: include_summary_of_changes âˆ§ checklist_status,
  labeling: derive_from_types_allowed
}

## ğŸ§­ Commands (Background Agent)

Î²G_commands = {
  "/bg-start": start_autonomous_loop(Î©_bg),
  "/bg-stop": stop_autonomous_loop(),
  "/bg-status": report_current_mode âˆ§ gates_state âˆ§ next_actions,
  "/bg-commit": run(G_commit) âˆ§ semantic_commit_if_pass(),
  "/bg-config": set({granularity_constraints, timeouts, max_iterations})
}

## ğŸš¦ Safety & Boundaries

constraints = {
  respect_protection_markers: true,           // Î¨ behaviors
  no_large_refactors_without_plan: true,      // must pass via Î©â‚ƒ
  stop_on_repeated_gate_failures: 3,          // prevent loops
  seek_human_on_blockers: true                // escalate when stuck
}

on_gate_failure(kind) = {
  capture_logs(kind),
  attempt_auto_fix â‰¤ 2,
  if still_failing â‡’ stop_autonomous_loop() âˆ§ request_human_input
}

## ğŸ”— References

links = {
  RIPER_core: "ripersigma105.mdc",
  LSMCP_rules: "mcp-lsmcp.mdc",
  Protection_rules: "codeprotection.mdc"
}
